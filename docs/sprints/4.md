# Sprint 4: Arquitetura Plugin-Based com Structured Outputs

**Per√≠odo**: 2025-07-15 a 2025-08-05 (3 semanas)
**Objetivo Principal**: Refatorar a arquitetura para um sistema baseado em plugins com separation of concerns entre DTOs e objetos de dom√≠nio

## Contexto e Motiva√ß√£o

A Sprint 4 marca uma evolu√ß√£o fundamental na arquitetura do IonNutri, transitioning de uma abordagem monol√≠tica para uma arquitetura plugin-based que suporta m√∫ltiplos pain√©is cl√≠nicos. Esta sprint implementa as li√ß√µes aprendidas do demo de structured outputs (`ml/demos/structured_outputs/main.py`) e estabelece uma separa√ß√£o clara entre concerns de API (DTOs) e l√≥gica de neg√≥cio (domain objects).

### Problemas Atuais que a Sprint 4 Resolve

1. **Mistura de Responsabilidades**: Atualmente, schemas Pydantic misturam valida√ß√£o de entrada HTTP com regras de neg√≥cio cl√≠nico
2. **Extensibilidade Limitada**: Adicionar novos pain√©is cl√≠nicos (VidaNova, etc.) requer modifica√ß√µes em m√∫ltiplos pontos do sistema
3. **Outputs N√£o Estruturados**: LLM ainda retorna texto que precisa ser parseado manualmente
4. **Acoplamento API-Dom√≠nio**: Mudan√ßas cl√≠nicas impactam contratos de API desnecessariamente
5. **M√∫ltiplos Formatos de Anamnese**: Sistema atual assume formato √∫nico, mas precisamos suportar:
   - **IonNutri**: 34 campos detalhados (foco cl√≠nico abrangente)
   - **VidaNova**: 18 campos simplificados (foco performance f√≠sica)
   - Estruturas de dados e l√≥gicas de processamento completamente diferentes

### Objetivos da Sprint 4

- **Separa√ß√£o Clara**: Estabelecer boundaries definitivos entre `app/schemas/` (DTOs) e `app/domain/` (business objects)
- **Plugin Architecture**: Permitir extens√£o do sistema atrav√©s de plugins isolados e test√°veis
- **Structured Outputs**: Tornar structured outputs o padr√£o obrigat√≥rio para todas as intera√ß√µes LLM
- **Extensibilidade**: Facilitar adi√ß√£o de novos pain√©is cl√≠nicos sem modificar c√≥digo existente
- **Backward Compatibility**: Manter 100% de compatibilidade com API atual

### Resultados Esperados

Ao final da Sprint 4, o sistema ter√°:
- Arquitetura plugin-based funcional com IonNutriPlugin e VidaNovaPlugin (stub)
- Separa√ß√£o completa entre DTOs (`schemas/`) e domain objects (`domain/`)
- Structured outputs obrigat√≥rio em todas as chamadas LLM
- Pipeline sequencial de N est√°gios integrado ao novo architecture
- MLflow tracing para auditoria de decis√µes cl√≠nicas
- Base s√≥lida para expans√£o para outros pain√©is cl√≠nicos

---

## Conceitos Fundamentais para Trainees e Dev Jr

Esta se√ß√£o explica os conceitos arquiteturais centrais da Sprint 4 para facilitar o entendimento e execu√ß√£o das tarefas.

### 1. DTOs vs Domain Objects

**Data Transfer Objects (DTOs)** s√£o objetos simples que servem apenas para transferir dados entre camadas, especialmente atrav√©s de APIs. Eles representam o "formato do fio" (wire format).

**Domain Objects** s√£o objetos ricos que encapsulam l√≥gica de neg√≥cio e regras cl√≠nicas. Eles representam conceitos do mundo real m√©dico.

```
# ‚ùå Antes: Misturado em schemas/
schemas/
‚îú‚îÄ‚îÄ exam.py          # DTO + valida√ß√£o + l√≥gica cl√≠nica (tudo misturado)
‚îú‚îÄ‚îÄ report.py        # DTO + regras m√©dicas + formata√ß√£o (confuso)

# ‚úÖ Depois: Separado por responsabilidade
schemas/             # Apenas DTOs para API
‚îú‚îÄ‚îÄ exam.py          # S√≥ formato de entrada HTTP
‚îú‚îÄ‚îÄ report_out.py    # S√≥ formato de sa√≠da HTTP

domain/              # S√≥ l√≥gica de neg√≥cio
‚îú‚îÄ‚îÄ exam_schema.py   # Valida√ß√£o de regras cl√≠nicas
‚îú‚îÄ‚îÄ status.py        # Conceitos m√©dicos (NORMAL, DEFICIENT)
‚îú‚îÄ‚îÄ report_model.py  # Agrega√ß√£o de informa√ß√µes cl√≠nicas
```

**Por que separar?**
- DTOs mudam quando API muda (formato, versioning)
- Domain objects mudam quando regras m√©dicas mudam
- Separar permite evolu√ß√£o independente

### 2. Plugin Architecture

Um **plugin** √© um m√≥dulo independente que implementa funcionalidade espec√≠fica sem conhecer outros plugins. No nosso caso, cada painel cl√≠nico (IonNutri, VidaNova) √© um plugin.

```
# Interface comum que todos os plugins devem implementar
class ReportPlugin:
    def build_report(exam: dict, anamnesis: dict) -> TNMReport

# Implementa√ß√µes espec√≠ficas
class IonNutriPlugin(ReportPlugin):
    # L√≥gica espec√≠fica para TNM

class VidaNovaPlugin(ReportPlugin):
    # L√≥gica espec√≠fica para VidaNova
```

**Benef√≠cios:**
- Adicionar novo painel = criar novo plugin (sem modificar c√≥digo existente)
- Cada plugin pode ter sua pr√≥pria l√≥gica e evolu√ß√£o
- Testes isolados por plugin
- Facilita manuten√ß√£o e debugging

### 3. Structured Outputs

**Antes**: LLM retorna texto livre que precisamos "parsear" manualmente
```python
response = llm.call("Analise este exame...")
# response = "O paciente apresenta defici√™ncia de B12..."
# Precisamos extrair informa√ß√µes com regex ou parsing manual
```

**Depois**: LLM retorna JSON estruturado validado automaticamente
```python
response = llm.call_llm_api(prompt, schema=FindingsSection)
# response = FindingsSection(items=[...], conclusion="...")
# J√° vem validado e tipado!
```

**Vantagens:**
- Elimina erros de parsing
- Valida√ß√£o autom√°tica com Pydantic
- Mais confi√°vel e test√°vel
- Reduz c√≥digo de tratamento de texto

### 4. Value Objects vs Aggregate Roots

**Value Object**: Objeto que representa um valor imut√°vel, sem identidade pr√≥pria
```python
# Status √© value object - representa um conceito, n√£o uma entidade
class Status(Enum):
    NORMAL = "normal"
    DEFICIENT = "deficient"
```

**Aggregate Root**: Objeto que coordena outros objetos e mant√©m consist√™ncia
```python
# TNMReport √© aggregate root - coordena Status, recomenda√ß√µes, etc.
class TNMReport:
    def __init__(self):
        self.status: Status
        self.recommendations: List[Recommendation]

    def add_recommendation(self, rec: Recommendation):
        # L√≥gica para manter consist√™ncia
```

### 5. Separation of Concerns (Separa√ß√£o de Responsabilidades)

Cada arquivo/classe/m√≥dulo deve ter **uma √∫nica responsabilidade bem definida**.

```
app/schemas/         # Responsabilidade: Formato de dados para API
app/domain/          # Responsabilidade: Regras de neg√≥cio cl√≠nico
app/plugins/         # Responsabilidade: L√≥gica espec√≠fica por painel
app/services/        # Responsabilidade: Orquestra√ß√£o e infraestrutura
```

**Regra pr√°tica**: Se voc√™ est√° em d√∫vida onde colocar algo, pergunte:
- "Isso muda quando a API muda?" ‚Üí `schemas/`
- "Isso muda quando as regras m√©dicas mudam?" ‚Üí `domain/`
- "Isso √© espec√≠fico de um painel cl√≠nico?" ‚Üí `plugins/`
- "Isso coordena outras partes do sistema?" ‚Üí `services/`

### 6. Interface Segregation

Em vez de uma interface grande com muitos m√©todos, criamos interfaces pequenas e espec√≠ficas.

```python
# ‚ùå Interface muito grande
class LLMService:
    def call_llm()
    def parse_response()
    def validate_json()
    def format_prompt()
    def handle_errors()
    # ... 20 m√©todos diferentes

# ‚úÖ Interfaces focadas
class LLMService:
    def call_llm_api(prompt, schema)  # Structured outputs obrigat√≥rio

class PromptManager:
    def format_prompt()    # Separado por responsabilidade
```

### 7. Dependency Flow (Fluxo de Depend√™ncias)

As depend√™ncias devem fluir das camadas externas (API) para as internas (domain).

```
API Layer (schemas/)
    ‚Üì depends on
Services Layer (services/)
    ‚Üì depends on
Domain Layer (domain/)
    ‚Üì depends on
Infrastructure (db/, external APIs)
```

**Regra**: Domain nunca depende de API ou Services. API pode depender de Domain.

### 8. Backward Compatibility

Manter **compatibilidade reversa** significa que clientes existentes da API continuam funcionando sem modifica√ß√µes, mesmo com mudan√ßas internas.

**Como garantir:**
- Response format permanece igual externamente
- Campos obrigat√≥rios n√£o s√£o removidos
- Novos campos s√£o opcionais
- DTOs wrapper isolam mudan√ßas internas

### 9. exam_type vs anamnesis_type: Conceitos Distintos

**IMPORTANTE**: Estes s√£o conceitos diferentes e independentes:

- **exam_type** (query parameter): Define **qual plugin usar** para processamento
- **anamnesis_type** (payload): Define **qual formato de dados** est√° chegando

```python
# Exemplo: Processamento VidaNova com dados no formato IonNutri
POST /api/v1/reports/?exam_type=vidanova
{
  "anamnesis": {
    "anamnesis_type": "ionnutri",  # Formato dos dados
    "family_history": {...},       # 34 campos completos
    "medications": [...]
  }
}

# Resultado: Plugin VidaNova processa dados completos do IonNutri
```

**Combina√ß√µes poss√≠veis:**
- `exam_type=ionnutri` + `anamnesis_type=ionnutri` ‚úÖ (atual)
- `exam_type=vidanova` + `anamnesis_type=vidanova` ‚úÖ (novo)

**Fluxo:**
1. **Pydantic** usa `anamnesis_type` para validar formato automaticamente
2. **ReportCoordinator** usa `exam_type` para selecionar plugin
3. **Plugin** recebe dados j√° validados e tipados

---

## Exemplos de C√≥digo para Implementa√ß√£o

Esta se√ß√£o fornece exemplos concretos para facilitar a implementa√ß√£o pelas equipes.

### 1. Plugin Interface (Tarefa 4.5)

```python
# app/plugins/base.py
from abc import ABC, abstractmethod
from typing import Union
from app.schemas.exam import ExamDTO
from app.schemas.patient_anamnesis import AnamnesisUnion
from app.domain.kg_result import KGResult
from app.domain.report import TNMReport

class ReportPlugin(ABC):
    """Interface que todos os plugins devem implementar"""

    @abstractmethod
    def build_report(
        self,
        exam_dto: ExamDTO,
        anamnesis_dto: AnamnesisUnion,  # J√° validado pelo Pydantic
        kg_result: KGResult
    ) -> TNMReport:
        """Constr√≥i relat√≥rio usando dados validados e contexto do grafo"""
        pass

    @abstractmethod
    def get_plugin_name(self) -> str:
        """Nome do plugin para registro"""
        pass
```

### 2. Plugin Implementation Example (Tarefa 4.5)

```python
# app/plugins/ionnutri_plugin.py
from app.plugins.base import ReportPlugin
from app.services.llm_service import LLMService

class IonNutriPlugin(ReportPlugin):
    def __init__(self, llm_service: LLMService):
        self.llm_service = llm_service

    def build_report(self, exam_dto, anamnesis_dto, kg_result) -> TNMReport:
        # Plugin √© agn√≥stico ao tipo de anamnesis
        # Funciona com IonNutriAnamnesis OU VidaNovaAnamnesis

        # Stage 1: Findings
        findings = self.llm_service.call_llm_api(
            prompt=self._get_findings_prompt(exam_dto, anamnesis_dto, kg_result),
            schema=FindingsSection
        )

        # Stage 2-7: Outros est√°gios...
        # ...

        return TNMReport(findings=findings, ...)

    def get_plugin_name(self) -> str:
        return "ionnutri"

    def _get_findings_prompt(self, exam, anamnesis, kg_result) -> str:
        # Prompt espec√≠fico do IonNutri
        return f"""Analise os resultados do exame {exam.exam_data}
        considerando contexto cl√≠nico {kg_result.clinical_context}..."""
```

### 3. ReportCoordinator (Tarefa 4.7)

```python
# app/services/report_coordinator.py
from typing import Dict
from app.plugins.base import ReportPlugin
from app.db.unified_query import UnifiedQuery

class ReportCoordinator:
    def __init__(self):
        self.plugins: Dict[str, ReportPlugin] = {}
        self.unified_query = UnifiedQuery()

    def register_plugin(self, plugin: ReportPlugin):
        """Registra plugin no sistema"""
        self.plugins[plugin.get_plugin_name()] = plugin

    def generate_report(self, exam_type: str, exam_dto, anamnesis_dto):
        # 1. Selecionar plugin baseado em exam_type
        if exam_type not in self.plugins:
            raise ValueError(f"Plugin n√£o encontrado: {exam_type}")
        plugin = self.plugins[exam_type]

        # 2. Consultar grafo de forma gen√©rica
        kg_result = self.unified_query.get_patient_context(exam_dto, anamnesis_dto)

        # 3. Plugin processa dados j√° validados
        domain_report = plugin.build_report(exam_dto, anamnesis_dto, kg_result)

        return domain_report
```

### 4. API Endpoint (Tarefa 4.8)

```python
# app/api/endpoints/reports.py
from fastapi import APIRouter, Query, Depends
from app.schemas.exam import ExamDTO
from app.schemas.patient_anamnesis import AnamnesisUnion
from app.schemas.report_out import ReportOut
from app.services.report_coordinator import ReportCoordinator

router = APIRouter()

@router.post("/reports/", response_model=ReportOut)
async def generate_report(
    exam_data: ExamDTO,
    anamnesis: AnamnesisUnion,  # Pydantic resolve automaticamente
    exam_type: str = Query(default="ionnutri", description="Plugin type: ionnutri, vidanova"),
    coordinator: ReportCoordinator = Depends(get_coordinator)
):
    # Pydantic j√° validou anamnesis baseado em anamnesis_type
    # exam_type determina qual plugin usar

    domain_report = coordinator.generate_report(exam_type, exam_data, anamnesis)

    # Converter domain object para DTO
    return ReportOut.from_domain(domain_report)
```

### 5. Discriminated Union para Anamnesis (Tarefa 4.8)

```python
# app/schemas/patient_anamnesis.py
from typing import Union, Literal
from pydantic import BaseModel, Field

class IonNutriAnamnesis(BaseModel):
    anamnesis_type: Literal["ionnutri"] = "ionnutri"
    # 34 campos espec√≠ficos
    family_history: dict = Field(description="Hist√≥rico familiar detalhado")
    medications: list = Field(description="Medicamentos em uso")
    environmental_exposure: dict = Field(description="Exposi√ß√µes ambientais")
    # ... outros 31 campos

class VidaNovaAnamnesis(BaseModel):
    anamnesis_type: Literal["vidanova"] = "vidanova"
    # 18 campos espec√≠ficos
    diet_type: str = Field(description="Tipo de dieta: on√≠vora, vegetariana, etc.")
    energy_level: int = Field(ge=1, le=5, description="N√≠vel de energia 1-5")
    muscle_gain_goal: int = Field(ge=1, le=5, description="Objetivo ganho muscular")
    # ... outros 15 campos

# Uni√£o discriminada - Pydantic resolve automaticamente
AnamnesisUnion = Union[IonNutriAnamnesis, VidaNovaAnamnesis]
```

### 6. KGResult Domain Object (Tarefa 4.1)

```python
# app/domain/kg_result.py (renomeado de tnm_result.py)
from typing import List, Optional
from app.domain.status import Status

class KGResult:
    """Resultado agregado do Knowledge Graph - serve para qualquer plugin"""

    def __init__(
        self,
        status: Status,
        nutrients: List[dict],
        clinical_context: Optional[dict] = None,
        performance_context: Optional[dict] = None
    ):
        self.status = status
        self.nutrients = nutrients
        self.clinical_context = clinical_context  # Para IonNutri
        self.performance_context = performance_context  # Para VidaNova

    def has_clinical_data(self) -> bool:
        """Verifica se tem dados cl√≠nicos (IonNutri)"""
        return self.clinical_context is not None

    def has_performance_data(self) -> bool:
        """Verifica se tem dados de performance (VidaNova)"""
        return self.performance_context is not None
```

---

## Diagrama de Classes da Arquitetura Alvo

```mermaid
classDiagram
    class `app.api.APIEndpoint` {
        +generate_report()
    }

    class `app.schemas.ExamDTO` {
        +exam_data: dict
    }

    class `app.schemas.AnamnesisUnion` {
        <<Union>>
    }

    class `app.schemas.IonNutriAnamnesis` {
        +anamnesis_type: ionnutri
        +family_history
        +medications
    }

    class `app.schemas.VidaNovaAnamnesis` {
        +anamnesis_type: vidanova
        +diet_type
        +energy_level
    }

    class `app.schemas.ReportOut` {
        +report_id
        +timestamp
        +markdown_content
    }

    class `app.services.ReportCoordinator` {
        +plugins
        +unified_query
        +register_plugin()
        +generate_report()
    }

    class `app.services.LLMService` {
        +call_llm_api()
    }

    class `app.plugins.ReportPlugin` {
        <<Abstract>>
        +build_report()
        +get_plugin_name()
    }

    class `app.plugins.IonNutriPlugin` {
        +build_report()
        +get_plugin_name()
        +prompts: IonNutriPrompts
    }

    class `app.plugins.VidaNovaPlugin` {
        +build_report()
        +get_plugin_name()
        +prompts: VidaNovaPrompts
    }

    class `app.plugins.prompts.IonNutriPrompts` {
        +get_findings_prompt()
        +get_deficiencies_prompt()
        +get_nutrition_prompt()
        +get_supplements_prompt()
    }

    class `app.plugins.prompts.VidaNovaPrompts` {
        +get_performance_prompt()
        +get_fitness_prompt()
    }

    class `app.domain.KGResult` {
        +status
        +nutrients
        +clinical_context
        +performance_context
        +has_clinical_data()
        +has_performance_data()
    }

    class `app.domain.Status` {
        <<Enumeration>>
        NORMAL
        DEFICIENT
        OPTIMAL
    }

    class `app.domain.TNMReport` {
        +findings
        +recommendations
        +status
    }

    class `app.db.UnifiedQuery` {
        +get_patient_context()
    }

    %% Relationships
    `app.api.APIEndpoint` --> `app.services.ReportCoordinator`
    `app.api.APIEndpoint` --> `app.schemas.ExamDTO`
    `app.api.APIEndpoint` --> `app.schemas.AnamnesisUnion`
    `app.api.APIEndpoint` --> `app.schemas.ReportOut`

    `app.schemas.AnamnesisUnion` <|-- `app.schemas.IonNutriAnamnesis`
    `app.schemas.AnamnesisUnion` <|-- `app.schemas.VidaNovaAnamnesis`

    `app.services.ReportCoordinator` --> `app.plugins.ReportPlugin`
    `app.services.ReportCoordinator` --> `app.db.UnifiedQuery`
    `app.services.ReportCoordinator` --> `app.domain.TNMReport`

    `app.plugins.ReportPlugin` <|-- `app.plugins.IonNutriPlugin`
    `app.plugins.ReportPlugin` <|-- `app.plugins.VidaNovaPlugin`

    `app.plugins.IonNutriPlugin` --> `app.services.LLMService`
    `app.plugins.VidaNovaPlugin` --> `app.services.LLMService`
    `app.plugins.IonNutriPlugin` --> `app.domain.TNMReport`
    `app.plugins.VidaNovaPlugin` --> `app.domain.TNMReport`
    `app.plugins.IonNutriPlugin` --> `app.plugins.prompts.IonNutriPrompts`
    `app.plugins.VidaNovaPlugin` --> `app.plugins.prompts.VidaNovaPrompts`

    `app.db.UnifiedQuery` --> `app.domain.KGResult`
    `app.domain.KGResult` --> `app.domain.Status`
    `app.domain.TNMReport` --> `app.domain.Status`

    `app.schemas.ReportOut` --> `app.domain.TNMReport`
```

---

## Arquitetura Alvo da Sprint 4

Esta se√ß√£o apresenta a arquitetura que obteremos ao final da Sprint 4, contrastando com a arquitetura atual e demonstrando os benef√≠cios da evolu√ß√£o proposta.

### Evolu√ß√£o Arquitetural: Antes vs Depois

#### Arquitetura Atual (Antes da Sprint 4)

```mermaid
%%{init: {'theme': 'default', 'themeVariables': { 'fontFamily': 'arial' }}}%%

graph TD
    subgraph "API Layer"
        API[FastAPI Endpoints]
        Deps[Dependencies]
    end

    subgraph "Services Layer"
        TNM[TNMService<br/>‚Ä¢ Orquestrador monol√≠tico<br/>‚Ä¢ L√≥gica espec√≠fica TNM<br/>‚Ä¢ Parsing manual LLM]
        LLM[LLMService<br/>‚Ä¢ Respostas texto livre<br/>‚Ä¢ Parsing manual]
    end

    subgraph "Data Layer"
        Schemas[app.schemas<br/>‚Ä¢ DTOs + Domain mixed<br/>‚Ä¢ Responsabilidades confusas]
        KG[Neo4jKnowledgeQuery]
        Neo4j[(Neo4j)]
    end

    API --> TNM
    TNM --> LLM
    TNM --> KG
    KG --> Neo4j
    TNM --> Schemas

    classDef current fill:#ffebee,stroke:#d32f2f,stroke-width:2px
    classDef problem fill:#fff3e0,stroke:#f57c00,stroke-width:2px
    class TNM,LLM,Schemas current
    class API,Deps,KG problem
```

**Problemas da Arquitetura Atual:**
- **Acoplamento Alto**: TNMService mistura orquestra√ß√£o com l√≥gica espec√≠fica TNM
- **Responsabilidades Confusas**: `schemas/` mistura DTOs com domain logic
- **Parsing Manual**: LLM retorna texto que precisa ser parseado
- **Extensibilidade Limitada**: Adicionar novo painel requer modificar TNMService
- **Testing Complexo**: L√≥gica de neg√≥cio acoplada √† infraestrutura

#### Arquitetura Alvo (Ap√≥s Sprint 4)

```mermaid
%%{init: {'theme': 'default', 'themeVariables': { 'fontFamily': 'arial' }}}%%

graph TD
    subgraph "API Layer"
        API[FastAPI Endpoints<br/>‚Ä¢ exam_type parameter<br/>‚Ä¢ Backward compatible]
        DTOs[app.schemas<br/>‚Ä¢ Pure DTOs only<br/>‚Ä¢ Wire format focused]
    end

    subgraph "Orchestration Layer"
        RC[ReportCoordinator<br/>‚Ä¢ Plugin selection<br/>‚Ä¢ Flow orchestration<br/>‚Ä¢ Error handling]
        MLT[MLflow Tracing<br/>‚Ä¢ Audit trail<br/>‚Ä¢ Performance metrics]
    end

    subgraph "Domain Layer"
        Domain[app.domain<br/>‚Ä¢ Business rules<br/>‚Ä¢ Clinical validation<br/>‚Ä¢ Value objects]
    end

    subgraph "Plugin Architecture"
        PI[ReportPlugin Interface]
        IONPlug[IonNutriPlugin<br/>‚Ä¢ 7-stage pipeline<br/>‚Ä¢ Clinical comprehensive<br/>‚Ä¢ 34-field anamnesis]
        VNPlug[VidaNovaPlugin<br/>‚Ä¢ Performance pipeline<br/>‚Ä¢ Fitness focused<br/>‚Ä¢ 18-field anamnesis]
    end

    subgraph "Infrastructure"
        LLM[LLMService<br/>‚Ä¢ Structured outputs only<br/>‚Ä¢ Schema validation]
        KG[Neo4jKnowledgeQuery]
        Neo4j[(Neo4j)]
    end

    API --> DTOs
    API --> RC
    RC --> PI
    IONPlug -.-> PI
    VNPlug -.-> PI
    IONPlug --> Domain
    VNPlug --> Domain
    IONPlug --> LLM
    VNPlug --> LLM
    RC --> KG
    KG --> Neo4j
    RC --> MLT
    DTOs --> Domain

    classDef target fill:#e8f5e8,stroke:#2e7d32,stroke-width:2px
    classDef plugin fill:#e3f2fd,stroke:#1976d2,stroke-width:2px
    classDef domain fill:#f3e5f5,stroke:#7b1fa2,stroke-width:2px
    class API,DTOs,RC target
    class PI,TNMPlug,VNPlug plugin
    class Domain domain
```

### Estrutura de Diret√≥rios Resultante

```
ion-nutri/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ api/                    # API Layer - Wire Format
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ endpoints/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ reports.py      # ‚ú® Plugin selection via exam_type
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dependencies.py     # ‚ú® ReportCoordinator injection
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ router.py
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ schemas/                # üîÑ Pure DTOs - Wire Format Only
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ exam.py             # DTO: HTTP input format
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ patient_anamnesis.py # DTO: HTTP input format (with discriminated unions)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ report_out.py       # ‚ú® NEW: DTO wrapper for outputs
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ domain/                 # ‚ú® NEW: Business Rules & Clinical Logic
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ status.py           # üîÑ MOVED: Value objects
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ kg_result.py        # üîÑ MOVED+RENAMED: Knowledge Graph aggregates
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ report.py           # üîÑ MOVED: Report domain model
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ plugins/                # ‚ú® NEW: Plugin Architecture
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py             # ‚ú® ReportPlugin interface
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ionnutri_plugin.py  # ‚ú® TNM-specific implementation
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ vidanova_plugin.py  # ‚ú® VidaNova stub implementation
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ prompts/            # ‚ú® NEW: Plugin-owned prompts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ ionnutri_prompts.py  # ‚ú® TNM prompts isolados
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ vidanova_prompts.py  # ‚ú® VidaNova prompts isolados
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ services/               # Orchestration & Infrastructure
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ report_coordinator.py # ‚ú® NEW: Replaces TNMService
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ llm_service.py      # üîÑ UPDATED: Structured outputs only
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ prompt_manager.py   # ‚ú® NEW: Separated from LLMService
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ db/                     # Data Access Layer
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ neo4j_client.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ unified_query.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ knowledge_graph_builder.py
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îî‚îÄ‚îÄ mlflow_tracing.py   # ‚ú® NEW: Audit & monitoring
```

### Decis√£o: Plugin Owns Prompts Strategy

Uma an√°lise do demo `ml/demos/structured_outputs/main.py` revelou que a classe `PromptManager` atual √© um **antipattern God Class** com m√∫ltiplas responsabilidades:
- 7 system prompts diferentes misturados
- 90+ linhas de l√≥gica condicional em `build_user_prompt()`
- Acoplamento alto entre stages
- Viola√ß√£o do Open/Closed Principle

**Solu√ß√£o adotada**: Cada plugin possui e gerencia seus pr√≥prios prompts isoladamente.

#### Implementa√ß√£o Sprint 4 (Simplificada)
```python
# app/plugins/prompts/ionnutri_prompts.py
class IonNutriPrompts:
    """Prompts espec√≠ficos do TNM IonNutri - isolados e test√°veis"""

    def get_findings_prompt(self, exam_dto, anamnesis_dto, kg_result) -> Tuple[str, str]:
        system = """Especialista em medicina nutricional TNM..."""
        user = f"""# DADOS DO PACIENTE\n{exam_dto.model_dump()}..."""
        return system, user

    def get_supplements_prompt(self, exam_dto, anamnesis_dto, context) -> Tuple[str, str]:
        # L√≥gica conservadora espec√≠fica TNM
        system = """Abordagem conservadora TNM para suplementa√ß√£o..."""
        user = f"""# CONTEXTO ANTERIOR\n{context}..."""
        return system, user

# app/plugins/ionnutri_plugin.py
class IonNutriPlugin(ReportPlugin):
    def __init__(self, llm_service: LLMService):
        self.llm_service = llm_service
        self.prompts = IonNutriPrompts()  # ‚Üê Prompts isolados

    def build_report(self, exam_dto, anamnesis_dto, kg_result):
        # Use prompts pr√≥prios
        system, user = self.prompts.get_findings_prompt(exam_dto, anamnesis_dto, kg_result)
        findings = self.llm_service.call_llm_api(user, system, FindingsSection)
        # ...
```

#### Evolu√ß√£o Sprint 5+ (MLflow Advanced)
```python
class IonNutriPrompts:
    def get_prompt_config(self) -> PromptConfig:
        return PromptConfig(
            plugin_name="ionnutri",
            version="v2.1",
            templates={
                "findings": "ionnutri_findings_v2.1.jinja",
                "supplements": "ionnutri_supplements_v2.1.jinja"
            }
        )
    # MLflow automaticamente: versioning, A/B testing, rollback granular
```

#### Benef√≠cios Imediatos
- **Isolation**: Mudan√ßas em prompts TNM n√£o afetam VidaNova
- **Clarity**: Cada plugin tem responsabilidade clara sobre seus prompts
- **Testing**: Prompts test√°veis isoladamente por plugin
- **Maintenance**: Debugging focado, sem code conditionals gigantes

### Principais Benef√≠cios da Nova Arquitetura

#### 1. Separation of Concerns
```python
# ‚ùå Antes: Misturado em schemas/report.py
class ReportModel(BaseModel):
    # DTO fields
    report_id: str
    timestamp: datetime

    # Domain logic
    def calculate_severity(self): ...
    def validate_clinical_rules(self): ...

    # API formatting
    def to_json_response(self): ...

# ‚úÖ Depois: Separado por responsabilidade

# schemas/report_out.py - Pure DTO
class ReportOut(BaseModel):
    report_id: str
    timestamp: datetime
    markdown_content: str
    # Only wire format, no logic

# domain/report.py - Pure Domain
class TNMReport:
    # Only business logic, no API concerns

# schemas/patient_anamnesis.py - Discriminated Union DTOs
from typing import Union, Literal
from pydantic import Field, BaseModel

class IonNutriAnamnesis(BaseModel):
    anamnesis_type: Literal["ionnutri"] = "ionnutri"
    family_history: dict
    medications: list
    # ... 32 outros campos

class VidaNovaAnamnesis(BaseModel):
    anamnesis_type: Literal["vidanova"] = "vidanova"
    diet_type: str
    energy_level: int
    # ... 16 outros campos

# Pydantic resolve automaticamente baseado em anamnesis_type
AnamnesisUnion = Union[IonNutriAnamnesis, VidaNovaAnamnesis]
```

#### 2. Plugin Extensibility
```python
# ‚úÖ Adicionar novo painel: apenas criar plugin
class HeartRateVariabilityPlugin(ReportPlugin):
    def build_report(self, exam: dict, anamnesis: dict) -> TNMReport:
        # HRV-specific logic isolated
        pass

# Sistema automaticamente descobre e registra
# Nenhuma modifica√ß√£o em c√≥digo existente necess√°ria
```

#### 3. Structured Outputs Obrigat√≥rio
```python
# ‚ùå Antes: Parsing manual propenso a erros
response = llm.call("Analyze this exam...")
# text = "Patient shows B12 deficiency..."
findings = manual_parse_findings(text)  # üí• Error prone

# ‚úÖ Depois: Schema-driven validation
response = llm.call_llm_api(prompt, schema=FindingsSection)
# response = FindingsSection(items=[...], severity=...)  # ‚ú® Validated
```

#### 4. Domain-Driven Flow
```mermaid
sequenceDiagram
    participant Client as Client
    participant API as API Endpoint
    participant RC as ReportCoordinator
    participant Plugin as Selected Plugin
    participant LLM as LLMService
    participant KG as Knowledge Graph

    Client->>API: POST /reports?exam_type=vidanova<br/>{anamnesis: {anamnesis_type: "ionnutri", ...}}
    API->>API: Pydantic validates anamnesis_type<br/>‚Üí IonNutriAnamnesis
    API->>RC: exam_type="vidanova", validated DTOs
    RC->>RC: Select plugin based on exam_type
    RC->>KG: Query with validated anamnesis data
    KG-->>RC: KGResult (domain object)
    RC->>Plugin: build_report(exam_dto, anamnesis_dto, kg_result)

    loop Plugin-specific pipeline
        Plugin->>LLM: call_llm_api(stage_prompt, schema=StageSchema)
        LLM-->>Plugin: validated_domain_object
        Plugin->>Plugin: aggregate_stage_results
    end

    Plugin-->>RC: TNMReport
    RC->>API: Convert Domain ‚Üí ReportOut DTO
    API-->>Client: ReportOut (JSON)
```

### M√©tricas de Melhoria Esperadas

| M√©trica | Antes | Depois | Melhoria |
|---------|-------|--------|----------|
| **Tempo para novo painel** | 5-7 dias | 1 dia | 85% redu√ß√£o |
| **Parsing errors** | 3-5% das chamadas | 0% | 100% elimina√ß√£o |
| **Test isolation** | Testes acoplados | Plugins isolados | 90% melhoria |
| **Code reuse** | 30% entre pain√©is | 80% entre pain√©is | 167% aumento |
| **Onboarding time** | 3-4 dias | 1-2 dias | 50% redu√ß√£o |

### Compatibilidade e Migra√ß√£o

#### Backward Compatibility Garantida
```python
# ‚úÖ Clientes existentes continuam funcionando
POST /api/v1/reports/
{
  "exam_data": {...},
  "anamnesis": {...}
}
# Automaticamente usa IonNutriPlugin (default)

# ‚úÖ Novos clientes podem especificar painel
POST /api/v1/reports/?exam_type=vidanova
{
  "exam_data": {...},
  "anamnesis": {...}
}
# Usa VidaNovaPlugin
```

#### Zero Downtime Migration
1. **Phase 1**: Adicionar domain/ mantendo schemas/ original
2. **Phase 2**: Implementar plugins mantendo TNMService como fallback
3. **Phase 3**: Migrar gradualmente para ReportCoordinator
4. **Phase 4**: Cleanup TNMService quando 100% migrado

### Extensibilidade Futura

A nova arquitetura facilita expans√µes futuras:

```python
# ‚úÖ Facilmente extens√≠vel para novos dom√≠nios
class CardiovascularPlugin(ReportPlugin): ...
class HormonalPlugin(ReportPlugin): ...
class GeneticPlugin(ReportPlugin): ...

# ‚úÖ Pipeline stages configur√°veis por plugin
class CustomPipelinePlugin(ReportPlugin):
    def get_pipeline_stages(self) -> List[PipelineStage]:
        return [CustomStage1(), CustomStage2(), ...]

# ‚úÖ Multiple output formats via DTOs
class PDFReportOut(BaseModel): ...
class ExcelReportOut(BaseModel): ...
class HL7ReportOut(BaseModel): ...
```

---

## Tarefas da Sprint 4

### 4.1: Refatorar schemas existentes para separa√ß√£o domain/DTO estabelecendo boundaries claros

**Respons√°veis**: Dev Jr + Trainee 1
**Dura√ß√£o**: 2 dias
**Depend√™ncias**: Nenhuma

#### Descri√ß√£o Detalhada

Esta tarefa implementa os 4 passos m√≠nimos de refatora√ß√£o para estabelecer a separa√ß√£o fundamental entre Data Transfer Objects (DTOs) e objetos de dom√≠nio. A refatora√ß√£o move arquivos estrat√©gicos para a nova estrutura de diret√≥rios sem quebrar funcionalidade existente.

#### Atividades Principais

- **Movimenta√ß√£o + Renaming**: Executar `git mv schemas/tnm_result.py domain/kg_result.py` e mover `status.py`, `report.py` para `domain/`
- **Renaming Classes**: Renomear `TNMResult` ‚Üí `KGResult` para refletir que vem do Knowledge Graph
- **Atualiza√ß√£o de Imports**: Modificar todas as refer√™ncias no codebase para nova estrutura e nomes
- **DTOs Permanecem**: `schemas/exam.py` e `schemas/patient_anamnesis.py` ficam como DTOs puros
- **ReportOut DTO**: Implementar `schemas/report_out.py` como wrapper transparente de TNMReport
- **Serialization Logic**: Configurar serializa√ß√£o autom√°tica TNMReport ‚Üí ReportOut DTO
- **OpenAPI Configuration**: Atualizar documenta√ß√£o autom√°tica para expor apenas DTOs
- **Valida√ß√£o de Integridade**: Garantir que sistema compile e execute exatamente como antes

#### Crit√©rios de Aceite

- [ ] Sistema executa sem erros ap√≥s movimenta√ß√£o e renaming
- [ ] Todos os testes existentes continuam passando
- [ ] `TNMResult` renomeado para `KGResult` em todo o codebase
- [ ] Imports atualizados para nova estrutura de diret√≥rios
- [ ] Separa√ß√£o conceitual clara: `schemas/` = wire format, `domain/` = business logic
- [ ] DTOs `exam.py` e `patient_anamnesis.py` permanecem em schemas/
- [ ] API exp√µe apenas DTOs, nunca domain objects diretamente
- [ ] OpenAPI spec limpo e focado em wire-format
- [ ] Serializa√ß√£o transparente TNMReport ‚Üí ReportOut DTO
- [ ] Compatibilidade total com clientes existentes

#### Benef√≠cios

Esta refatora√ß√£o estabelece a funda√ß√£o para isolation of change, onde mudan√ßas cl√≠nicas ficam contidas em `domain/` sem impactar contratos de API em `schemas/`. Facilita onboarding de novos desenvolvedores com responsabilidades claras por diret√≥rio.

Esta refatora√ß√£o estabelece a funda√ß√£o completa para isolation of change e arquitetura plugin-based, combinando movimenta√ß√£o de arquivos com cria√ß√£o de DTOs wrapper para exposi√ß√£o limpa da API.

---

### 4.2: Atualizar Knowledge Graph com ontologia completa e intervalos de refer√™ncia sint√©ticos

**Respons√°veis**: Trainee 1
**Dura√ß√£o**: 2 dias
**Depend√™ncias**: Tarefa 4.1

#### Descri√ß√£o Detalhada

Esta tarefa implementa a atualiza√ß√£o completa do grafo de conhecimento Neo4j com ontologia nutricional abrangente e intervalos de refer√™ncia sint√©ticos baseados em diretrizes cl√≠nicas reconhecidas, preparando a base de dados para suporte a m√∫ltiplos pain√©is cl√≠nicos (IonNutri e VidaNova).

#### Atividades Principais

- **Ontologia Nutricional Completa**: Expandir n√≥s e relacionamentos para cobrir nutrientes, biomarcadores e condi√ß√µes cl√≠nicas
- **Intervalos de Refer√™ncia Sint√©ticos**: Implementar valores de refer√™ncia baseados em guidelines estabelecidos (ANVISA, FDA, WHO)
- **N√≥s Multi-Panel**: Estruturar dados para suportar tanto an√°lises cl√≠nicas (TNM) quanto performance f√≠sica (VidaNova)
- **Relacionamentos Contextuais**: Criar conex√µes entre nutrientes, sintomas, condi√ß√µes e recomenda√ß√µes
- **Data Validation**: Implementar valida√ß√£o de consist√™ncia dos dados inseridos
- **Backup Strategy**: Estabelecer backup antes da atualiza√ß√£o para rollback se necess√°rio

#### Crit√©rios de Aceite

- [ ] Ontologia expandida com 50+ nutrientes essenciais e biomarcadores
- [ ] Intervalos de refer√™ncia sint√©ticos baseados em guidelines reconhecidos
- [ ] Estrutura de dados suporta queries tanto para IonNutri quanto VidaNova
- [ ] `unified_query.py` funciona com dados expandidos sem modifica√ß√µes
- [ ] Relacionamentos nutriente-sintoma-recomenda√ß√£o estabelecidos
- [ ] Valida√ß√£o de consist√™ncia implementada
- [ ] Backup realizado antes da atualiza√ß√£o
- [ ] Documenta√ß√£o dos intervalos de refer√™ncia utilizados

#### Benef√≠cios

Estabelece base robusta de conhecimento cl√≠nico para ambos os pain√©is (TNM e VidaNova). Intervalos sint√©ticos permitem desenvolvimento e testing enquanto aguarda dados reais do cliente. Estrutura flex√≠vel facilita atualiza√ß√£o posterior com dados propriet√°rios.

**Backlog Item**: Quando cliente fornecer dados reais, task de atualiza√ß√£o ser√° inserida automaticamente na sprint com prioridade alta.

---

### 4.3: Implementar Plugin Prompts para isolar prompts de cada plugin

**Respons√°veis**: Dev Jr + Trainee 3
**Dura√ß√£o**: 3 dias
**Depend√™ncias**: Tarefas 4.1, 4.2

#### Descri√ß√£o Detalhada

Esta tarefa implementa a estrat√©gia "Plugin Owns Prompts", criando classes isoladas de prompt management para cada plugin e eliminando a depend√™ncia do `PromptManager` monol√≠tico do demo. Cada plugin gerenciar√° seus pr√≥prios prompts de forma independente e test√°vel.

#### Atividades Principais

- **IonNutriPrompts Implementation**: Criar classe isolada com m√©todos `get_*_prompt()` para cada stage TNM
- **VidaNovaPrompts Stub**: Implementar stub de prompts para performance/fitness
- **Prompt Method Pattern**: Definir padr√£o consistente `get_stage_prompt(exam_dto, anamnesis_dto, context) -> Tuple[str, str]`
- **Legacy Prompt Migration**: Migrar prompts do `PromptManager` do demo para classes isoladas
- **TNM Template Integration**: Portar template TNM para `IonNutriPrompts`
- **Plugin Directory Structure**: Criar estrutura `app/plugins/prompts/` organizada
- **Prompt Testing**: Implementar testes unit√°rios para validar prompts isoladamente

#### Crit√©rios de Aceite

- [ ] `IonNutriPrompts` implementado com todos os 7 stages do pipeline TNM
- [ ] `VidaNovaPrompts` implementado como stub funcional para prompts de performance
- [ ] Cada classe de prompt retorna `(system_prompt, user_prompt)` consistently
- [ ] Elimina√ß√£o total da depend√™ncia do `PromptManager` monol√≠tico
- [ ] Prompts TNM mant√™m qualidade e especificidade cl√≠nica do demo original
- [ ] Templates isolados e version√°veis por plugin
- [ ] Testes unit√°rios para cada classe de prompt
- [ ] Documenta√ß√£o clara do padr√£o de prompt management

#### Benef√≠cios

Estabelece isolamento completo de prompts por plugin, elimina God Class antipattern, facilita testing e manuten√ß√£o independente. Prepara base para versioning e A/B testing futuro com MLflow.

---

### 4.4: Implementar structured outputs obrigat√≥rio eliminando parsing manual

**Respons√°veis**: Trainee 3
**Dura√ß√£o**: 2 dias
**Depend√™ncias**: Tarefa 4.1

#### Descri√ß√£o Detalhada

Esta tarefa elimina completamente respostas de texto n√£o estruturadas do LLM, implementando structured outputs como padr√£o obrigat√≥rio com valida√ß√£o autom√°tica atrav√©s dos domain objects j√° existentes (KGResult, Status, etc.) movidos na tarefa 4.1.

#### Atividades Principais

- **call_llm_api Method**: Atualizar assinatura para `call_llm_api(prompt: str, schema: Type[BaseModel])` que for√ßa JSON estruturado
- **OpenAI Integration**: Configurar `response_format` com schema derivado automaticamente de domain objects
- **Validation Pipeline**: Implementar valida√ß√£o autom√°tica de responses usando domain schemas (KGResult, Status, etc.)
- **Error Handling**: Desenvolver fallback robusto para casos de JSON mal formado

#### Crit√©rios de Aceite

- [ ] 100% das chamadas LLM retornam JSON estruturado validado
- [ ] Elimina√ß√£o total de parsing manual de respostas
- [ ] Integra√ß√£o transparente com Pydantic domain models
- [ ] Fallback graceful para erros de formato

#### Benef√≠cios

Elimina fonte principal de erros e inconsist√™ncias (parsing manual). Garante que outputs sempre conformem com domain schemas, melhorando confiabilidade e facilitating testing automatizado.

---

### 4.5: Construir framework plugin permitindo extens√£o modular do sistema

**Respons√°veis**: Dev Jr + Trainee 2
**Dura√ß√£o**: 2 dias
**Depend√™ncias**: Tarefas 4.1, 4.3

#### Descri√ß√£o Detalhada

Esta tarefa cria a infraestrutura fundamental para arquitetura plugin-based, permitindo que diferentes pain√©is cl√≠nicos (IonNutri, VidaNova, etc.) coexistam como m√≥dulos isolados e test√°veis, utilizando os domain objects e prompts isolados j√° implementados.

#### Atividades Principais

- **ReportPlugin Interface**: Definir contrato simples `build_report(exam_dto, anamnesis_dto, kg_result) -> TNMReport`
- **Plugin Registry**: Implementar registro baseado em `exam_type` (ionnutri, vidanova)
- **IonNutriPlugin Implementation**: Migrar l√≥gica TNM existente com pipeline de 7 est√°gios
- **VidaNovaPlugin Stub**: Implementar stub com pipeline placeholder (est√°gios a definir)
- **Prompt Integration**: Integrar plugins com classes de prompt j√° implementadas (`IonNutriPrompts`, `VidaNovaPrompts`)
- **Transparent Anamnesis**: Plugin recebe anamnesis j√° validada pelo Pydantic (transparente)

#### Crit√©rios de Aceite

- [ ] Interface `ReportPlugin` clara com m√©todo `build_report` definido
- [ ] Registry seleciona plugin baseado em `exam_type` do query parameter
- [ ] Plugins processam qualquer tipo de anamnesis (IonNutri ou VidaNova) transparentemente
- [ ] IonNutriPlugin funciona com pipeline de 7 est√°gios
- [ ] VidaNovaPlugin implementado como stub funcional
- [ ] Plugins integrados com classes de prompt isoladas via `self.prompts`
- [ ] Uso correto de `self.prompts.get_*_prompt()` em cada plugin

#### Benef√≠cios

Permite expans√£o horizontal do sistema sem modificar c√≥digo existente. Cada painel cl√≠nico pode evoluir independentemente, facilitando manuten√ß√£o e testing isolado.

---

### 4.6: Migrar pipeline sequencial integrando structured outputs com domain objects

**Respons√°veis**: Trainee 2 + Trainee 3
**Dura√ß√£o**: 4 dias
**Depend√™ncias**: Tarefas 4.4, 4.5

#### Descri√ß√£o Detalhada

Esta tarefa porta o pipeline sequencial de 7 est√°gios do demo [main.py](../../../ml/demos/structured_outputs/main.py) para dentro do IonNutriPlugin, integrando-o completamente com a nova arquitetura de domain objects e structured outputs.

#### Atividades Principais

- **Pipeline Integration**: Portar 7 est√°gios (Findings ‚Üí Deficiencies ‚Üí Nutrition ‚Üí Lifestyle ‚Üí Supplements ‚Üí Final Report ‚Üí Markdown) para IonNutriPlugin
- **Domain Schema Adaptation**: Adaptar cada est√°gio para produzir e consumir domain objects
- **Structured Flow**: Garantir que cada est√°gio use structured outputs com valida√ß√£o autom√°tica
- **Plugin Integration**: Integrar pipeline com framework de plugins e classes de prompt j√° implementadas
- **Sequential Context**: Implementar passagem de contexto entre est√°gios usando domain objects

#### Crit√©rios de Aceite

- [ ] Pipeline completo produz TNMReport domain object
- [ ] Mesma qualidade de output do demo original
- [ ] Structured outputs em todos os 7 est√°gios
- [ ] Integra√ß√£o transparente com domain objects
- [ ] Pipeline integrado com `IonNutriPrompts` via framework de plugins
- [ ] Contexto sequencial preservado entre est√°gios usando domain objects
- [ ] Mesmo fluxo e qualidade do demo original mas com arquitetura plugin-based

#### Benef√≠cios

Combina a qualidade comprovada do pipeline sequencial com a robustez da nova arquitetura. Structured outputs eliminam pontos de falha e domain objects facilitam testing e manuten√ß√£o.

---

### 4.7: Implementar ReportCoordinator orquestrando plugins de forma transparente

**Respons√°veis**: Trainee 2
**Dura√ß√£o**: 2 dias
**Depend√™ncias**: Tarefas 4.5, 4.6

#### Descri√ß√£o Detalhada

Esta tarefa cria o orquestrador central que substitui o TNMService, gerenciando sele√ß√£o de plugins, fluxo de dados entre camadas e mantendo compatibilidade com API existente.

#### Atividades Principais

- **Plugin Selection Logic**: Implementar sele√ß√£o baseada em `exam_type` query parameter
- **Generic Knowledge Graph**: Usar `unified_query.py` de forma gen√©rica (campos n√£o-null)
- **Data Flow Orchestration**: Coordenar DTO ‚Üí KG Query ‚Üí Plugin ‚Üí Domain Report
- **Error Handling**: Centralizar tratamento de erros e logging
- **Backward Compatibility**: Default `exam_type=ionnutri` mant√©m TNMService compat√≠vel

#### Crit√©rios de Aceite

- [ ] Sele√ß√£o correta de plugin baseado em `exam_type` query parameter
- [ ] `unified_query.py` funciona para ambos tipos de anamnesis (campos gen√©ricos)
- [ ] Orquestra√ß√£o: DTOs ‚Üí KGResult ‚Üí Plugin ‚Üí TNMReport ‚Üí ReportOut DTO
- [ ] Default `exam_type=ionnutri` mant√©m backward compatibility
- [ ] Logging e error handling centralizados com contexto de plugin

#### Benef√≠cios

Centraliza l√≥gica de orquestra√ß√£o sem acoplar plugins √† infraestrutura. Facilita debugging e monitoring enquanto mant√©m plugins focados em l√≥gica de neg√≥cio.

---

### 4.8: Atualizar API endpoints adicionando sele√ß√£o de plugin mantendo compatibilidade

**Respons√°veis**: Dev Jr + Trainee 1
**Dura√ß√£o**: 2 dias
**Depend√™ncias**: Tarefa 4.7

#### Descri√ß√£o Detalhada

Esta tarefa finaliza a migra√ß√£o da API para nova arquitetura, adicionando par√¢metro `exam_type` para sele√ß√£o de plugin e atualizando response models para usar DTOs wrapper, mantendo compatibilidade total com clientes existentes.

#### Atividades Principais

- **Plugin Selection Parameter**: Adicionar query parameter `exam_type` (default="ionnutri")
- **Discriminated Union**: Configurar `AnamnesisUnion` para valida√ß√£o autom√°tica via `anamnesis_type`
- **Response Model**: Usar `ReportOut` DTO como wrapper de `TNMReport`
- **ReportCoordinator Integration**: Substituir TNMService por ReportCoordinator
- **Two-Level Selection**: `exam_type` ‚Üí plugin, `anamnesis_type` ‚Üí validation
- **Backward Compatibility**: Clientes existentes funcionam sem modifica√ß√£o (defaults)

#### Crit√©rios de Aceite

- [ ] API externa mant√©m 100% de compatibilidade para clientes existentes
- [ ] Query parameter `exam_type` seleciona plugin (ionnutri, vidanova)
- [ ] Payload `anamnesis_type` permite valida√ß√£o autom√°tica via Pydantic Union
- [ ] Response estruturado via `TNMReport` ‚Üí `ReportOut` DTO
- [ ] Integra√ß√£o transparente com ReportCoordinator

#### Benef√≠cios

Expande capacidade da API para m√∫ltiplos pain√©is cl√≠nicos sem quebrar compatibilidade. Clientes existentes continuam funcionando, novos clientes podem especificar tipo de exame.

---

### 4.9: Implementar rastreamento MLflow capturando transforma√ß√µes domain para auditoria

**Respons√°veis**: Trainee 1
**Dura√ß√£o**: 2 dias
**Depend√™ncias**: Tarefa 4.7

#### Descri√ß√£o Detalhada

Esta tarefa integra MLflow tracing focado em capturar transforma√ß√µes de domain objects e decis√µes cl√≠nicas, fornecendo auditabilidade completa do processo de gera√ß√£o de relat√≥rios.

#### Atividades Principais

- **Domain Transformation Tracing**: Rastrear cada transforma√ß√£o de domain objects
- **Clinical Decision Logging**: Capturar decis√µes baseadas em Status, severidade, etc.
- **Performance Metrics**: Implementar m√©tricas baseadas em conceitos cl√≠nicos
- **Audit Dashboard**: Configurar visualiza√ß√µes para review cl√≠nico

#### Crit√©rios de Aceite

- [ ] Rastreamento completo do fluxo domain-driven
- [ ] M√©tricas clinicamente relevantes (distribui√ß√£o de Status, etc.)
- [ ] Auditabilidade de decis√µes de neg√≥cio
- [ ] Dashboard configurado para review cl√≠nico

#### Benef√≠cios

Fornece visibilidade completa sobre decis√µes cl√≠nicas para especialistas. Facilita debugging de casos edge e melhoria cont√≠nua da qualidade dos relat√≥rios.

---

## Depend√™ncias Entre Tarefas

```mermaid
graph TD
    subgraph "ONDA 1: Funda√ß√µes (Dias 1-2)"
        T1[4.1: Refatorar schemas<br/>Trainee 2]
        T2[4.2: Knowledge Graph<br/>Dev Jr]
        T4[4.4: Structured outputs<br/>Trainee 3]
    end

    subgraph "ONDA 2: Componentes (Dias 3-4)"
        T3[4.3: Plugin Prompts<br/>Dev Jr + Trainee 3]
        T5[4.5: Framework plugin<br/>Dev Jr + Trainee 2]
    end

    subgraph "ONDA 3: Teste de Habilidades (Dias 5-6)"
        T6[4.6: Pipeline sequencial<br/>Trainee 2 + Trainee 3<br/>üß™ TESTE DUPLO]
        T7[4.7: ReportCoordinator<br/>Dev Jr + Ambos Trainees<br/>üë®‚Äçüè´ MENTORIA ATIVA]
    end

    subgraph "ONDA 4: Finaliza√ß√£o (Dias 7-8)"
        T8[4.8: API endpoints<br/>Dev Jr SOLO]
        T9[4.9: MLflow tracing<br/>Dev Jr]
    end

    T1 --> T5
    T1 --> T3
    T4 --> T6
    T3 --> T6
    T5 --> T6
    T5 --> T7
    T6 --> T7
    T7 --> T8
    T2 --> T9
```

### Distribui√ß√£o de Responsabilidades

#### Dev Jr: Mentoria Ativa + Critical Path
- T2: Knowledge Graph (Solo - Dias 1-2)
- T3: Plugin Prompts (Pair com Trainee 3 - Dias 3-4)
- T5: Framework plugin (Pair com Trainee 2 - Dias 3-4)
- T7: ReportCoordinator (Mentoria com Ambos - Dias 5-6)
- T8: API endpoints (Solo - Dias 7-8)
- T9: MLflow tracing (Solo - Dias 7-8)

#### Trainee 2: Arquitetura Foundation + Teste
- T1: Refatorar schemas (Solo - Dias 1-2)
- T5: Framework plugin (Pair com Dev Jr - Dias 3-4)
- T6: Pipeline sequencial (TESTE com Trainee 3 - Dias 5-6)
- T7: ReportCoordinator (Mentoria com Dev Jr - Dias 5-6)

#### Trainee 3: LLM Specialist + Teste
- T4: Structured outputs (Solo - Dias 1-2)
- T3: Plugin Prompts (Pair com Dev Jr - Dias 3-4)
- T6: Pipeline sequencial (TESTE com Trainee 2 - Dias 5-6)
- T7: ReportCoordinator (Mentoria com Dev Jr - Dias 5-6)

### Pontos de Sincroniza√ß√£o

#### üî∏ Onda 1 ‚Üí 2 (Fim do Dia 2)
- **Checkpoint**: Domain objects movidos (T1)
- **Handoff**: Schemas ‚Üí Plugin Prompts (T3) e Framework (T5)
- **Time**: 5min standup

#### üî∏ Onda 2 ‚Üí 3 (Fim do Dia 4)
- **Checkpoint**: Plugin framework (T5) + Prompts (T3) prontos
- **Handoff**: Framework ‚Üí Pipeline (T6)
- **Time**: 15min demo + setup

#### üî∏ Onda 3 ‚Üí 4 (Fim do Dia 6)
- **Checkpoint**: Pipeline (T6) + Coordinator (T7) integrados
- **Handoff**: Coordinator ‚Üí API endpoints (T8)
- **Time**: 30min integration review

### Estrat√©gia de Teste de Habilidades (T6)

O Pipeline Sequencial (T6) serve como teste real das habilidades dos trainees, trabalhando em par sem interven√ß√£o direta do Dev Jr. Eles precisam:

1. Ler e entender o c√≥digo do demo (`ml/demos/structured_outputs/main.py`)
2. Portar o pipeline de 7 est√°gios para nova arquitetura
3. Integrar corretamente com:
   - Structured outputs (T4)
   - Plugin prompts (T3)
   - Plugin framework (T5)
   - Domain objects (T1)

O Dev Jr avalia o progresso durante as sess√µes de T7 (ReportCoordinator) sem intervir diretamente em T6.

### Contingency Plan

Se T6 apresentar problemas:

1. **Dia 5 (Problemas Parciais)**:
   - Dev Jr faz review session (30min)
   - Fornece guidance espec√≠fico sem implementar
   - Timeline pode estender at√© manh√£ do Dia 7

2. **Dia 6 (Problemas Cr√≠ticos)**:
   - Dev Jr assume T6 como teaching session
   - Trainees focam em aprendizado
   - T8 √© otimizada para compensar

## Riscos e Mitiga√ß√µes

### Riscos T√©cnicos

**Risco**: Quebra de compatibilidade durante refatora√ß√£o
**Mitiga√ß√£o**:
- Implementar testes de regress√£o antes de qualquer movimenta√ß√£o de arquivo
- Dev Jr review obrigat√≥rio em T1 antes de merge

**Risco**: Complexity creep na arquitetura plugin
**Mitiga√ß√£o**:
- Manter plugin interface minimal e bem documentada
- Code review focado em simplicidade durante T5

**Risco**: Performance degradation com structured outputs
**Mitiga√ß√£o**:
- Implementar benchmarks comparativos durante desenvolvimento
- Monitoramento via MLflow desde o in√≠cio

**Risco**: Confus√£o entre `exam_type` vs `anamnesis_type`
**Mitiga√ß√£o**:
- Documenta√ß√£o clara + exemplos no OpenAPI
- Coment√°rios explicativos no c√≥digo
- Valida√ß√£o autom√°tica via Pydantic

### Riscos de Arquitetura

**Risco**: Grafo gen√©rico n√£o atender necessidades espec√≠ficas
**Mitiga√ß√£o**:
- Estrat√©gia pragm√°tica para Sprint 4
- Especializa√ß√£o planejada para sprints futuras
- Valida√ß√£o com conjunto m√≠nimo de casos de uso

**Risco**: Duplica√ß√£o de prompts similares entre plugins
**Mitiga√ß√£o**:
- Sprint 4 foca em isolamento funcional
- Sprint 5+ abordar√° templates compartilhados
- Documenta√ß√£o clara de prompts por plugin

### Riscos de Implementa√ß√£o

**Risco**: Migra√ß√£o de prompts do demo quebrar funcionalidade
**Mitiga√ß√£o**:
- Portar prompts metodicamente stage por stage
- Manter qualidade via testes comparativos
- Pair programming Dev Jr + Trainee 3 em T3

**Risco**: Falha no teste de habilidades (T6)
**Mitiga√ß√£o**:
- Mentoria ativa nas tarefas preparat√≥rias (T3, T5)
- Checkpoints di√°rios durante T6
- Plano de conting√™ncia com Dev Jr como fallback

### Riscos de Integra√ß√£o

**Risco**: Conflitos de integra√ß√£o entre componentes paralelos
**Mitiga√ß√£o**:
- Pontos de sincroniza√ß√£o bem definidos entre ondas
- Interface contracts definidos no in√≠cio de cada onda
- Dev Jr review em pontos cr√≠ticos de integra√ß√£o

**Risco**: Atrasos em depend√™ncias cr√≠ticas
**Mitiga√ß√£o**:
- Buffer de 0.5 dia em cada onda
- Tasks cr√≠ticas (T1, T5) com Dev Jr involvement
- Plano de conting√™ncia por onda

## M√©tricas de Sucesso

- [ ] 100% dos testes existentes continuam passando
- [ ] 0 quebras de compatibilidade na API externa
- [ ] `TNMResult` ‚Üí `KGResult` renaming completo em todo codebase
- [ ] Suporte a ambos formatos: `anamnesis_type=ionnutri` e `anamnesis_type=vidanova`
- [ ] Plugin selection funciona via `exam_type` query parameter
- [ ] Combina√ß√µes flex√≠veis: `exam_type=vidanova` + `anamnesis_type=ionnutri`
- [ ] 100% das chamadas LLM usando structured outputs
- [ ] Grafo gen√©rico funciona para ambos tipos de anamnese
- [ ] VidaNovaPlugin implementado como stub funcional
- [ ] Knowledge Graph atualizado com 50+ nutrientes e intervalos sint√©ticos (Tarefa 4.2)
- [ ] `IonNutriPrompts` elimina depend√™ncia do `PromptManager` monol√≠tico (Tarefa 4.3)
- [ ] Cada plugin gerencia prompts isoladamente via `self.prompts.get_*_prompt()` (Tarefa 4.3)
- [ ] Framework plugin funcional com integration de prompts isolados (Tarefa 4.5)
- [ ] Mesma qualidade de output do demo original com prompts isolados (Tarefa 4.6)
- [ ] Cobertura de testes > 85% para novos componentes

## Decis√µes Adiadas para Sprints Futuras

Para manter o escopo da Sprint 4 gerenci√°vel e focado, as seguintes melhorias foram conscientemente adiadas:

### **Sprint 5: Specialized Knowledge Graph**
- Ontologias espec√≠ficas por plugin (cl√≠nico vs performance)
- Queries especializadas no `unified_query.py`
- N√≥s espec√≠ficos para VidaNova no Neo4j

### **Sprint 5: Advanced Prompt Management**
- Evolu√ß√£o de `IonNutriPrompts` para templates Jinja2 versionados
- Configura√ß√£o declarativa via `PromptConfig` com versioning
- Integra√ß√£o b√°sica com MLflow para prompt tracking

### **Sprint 6: Advanced Plugin Features**
- MLflow prompt versioning avan√ßado e A/B testing autom√°tico
- Templates compartilhados entre plugins (base prompts)
- Pipeline stages customiz√°veis por plugin
- Plugin-specific error handling e metrics
- Rollback granular de prompts por plugin+stage

### **Sprint 7: Performance & Optimization**
- Caching de queries por tipo de anamnese
- Parallel processing para diferentes plugins
- Advanced monitoring e alerting

Esta abordagem **incremental** permite que a equipe (1 Dev Jr + 2 Trainees) foque nos fundamentos arquiteturais sem se sobrecarregar com features avan√ßadas.
